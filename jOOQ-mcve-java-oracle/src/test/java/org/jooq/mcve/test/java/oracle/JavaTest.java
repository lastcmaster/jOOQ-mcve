package org.jooq.mcve.test.java.oracle;

import com.github.dockerjava.zerodep.shaded.org.apache.commons.codec.binary.Base64;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jooq.DSLContext;
import org.jooq.Result;
import org.jooq.SQLDialect;
import org.jooq.exception.DataAccessException;
import org.jooq.impl.DSL;
import org.jooq.mcve.java.oracle.Routines;
import org.jooq.mcve.java.oracle.tables.records.TMimedataReadRecord;
import org.jooq.tools.JooqLogger;
import org.junit.*;
import org.testcontainers.containers.OracleContainer;
import org.testcontainers.containers.wait.strategy.HostPortWaitStrategy;
import org.testcontainers.containers.wait.strategy.LogMessageWaitStrategy;
import org.testcontainers.containers.wait.strategy.WaitAllStrategy;
import org.testcontainers.shaded.org.apache.commons.lang3.StringUtils;
import org.testcontainers.utility.DockerImageName;
import org.testcontainers.utility.ResourceReaper;

import java.nio.ByteBuffer;
import java.sql.*;
import java.time.Duration;
import java.util.Random;
import java.util.UUID;

import static org.jooq.mcve.java.oracle.Tables.T_MIMEDATA;
import static org.jooq.mcve.java.oracle.Tables.T_MIMEDATA_READ;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

public class JavaTest {

    static JooqLogger log = JooqLogger.getLogger(JavaTest.class);
    static OracleContainer db;
    static Connection connection;
    static Connection sysConnection;
    static DSLContext ctx;

    static String sid;

    @BeforeClass
    public static void init() throws SQLException {
        if (System.getProperty("db.url") == null) {
            db = new OracleContainer(DockerImageName.parse("gvenzl/oracle-free").asCompatibleSubstituteFor("gvenzl/oracle-xe")) {
                @Override
                public String getSid() {
                    return "FREEPDB1";
                }

                ;

                @Override
                public String getDatabaseName() {
                    return "FREEPDB1";
                }

                ;
            }
                    .withUsername("MCVE")
                    .withPassword("MCVE")
                    .withEnv("ORACLE_PASSWORD", "MCVE")
                    .withEnv("APP_USER", "MCVE")
                    .withEnv("APP_USER_PASSWORD", "MCVE")
                    .waitingFor(new WaitAllStrategy()
                            .withStrategy(new LogMessageWaitStrategy()
                                    .withRegEx(".*DATABASE IS READY TO USE!.*"))
                            .withStrategy(new HostPortWaitStrategy())
                            .withStartupTimeout(Duration.ofMinutes(5))
                    )
                    .withInitScript("db/migration/init.sql");
            db.start();
            System.setProperty("db.url", db.getJdbcUrl());
            System.setProperty("db.username", db.getUsername());
            System.setProperty("db.password", db.getPassword());
        }

        log.info("Connecting");
        connection = DriverManager.getConnection(
                System.getProperty("db.url"),
                System.getProperty("db.username"),
                System.getProperty("db.password")
        );
        sysConnection = DriverManager.getConnection(
                System.getProperty("db.url"),
                "SYS as SYSDBA",
                "MCVE"
        );
        try (Statement s =
                     sysConnection.createStatement()) {
            s.execute("CREATE DIRECTORY MIMETEST AS '/var/tmp/'");
        }

        try (Statement s =
                     sysConnection.createStatement()) {
            s.execute("GRANT READ,WRITE ON DIRECTORY MIMETEST TO MCVE");
        }

        ctx = DSL.using(connection, SQLDialect.ORACLE);

        // Use JDBC directly instead of jOOQ to avoid DEBUG logging all of this
        try (Statement s = connection.createStatement()) {
        }
    }

    @AfterClass
    public static void end() {
        if (db != null) {
            ResourceReaper.instance().stopAndRemoveContainer(db.getContainerId(), db.getDockerImageName());
        }
    }

    @Before
    public void setup() throws Exception {
        ctx.delete(T_MIMEDATA).execute();
        try (PreparedStatement ps =
                     connection.prepareStatement("SELECT sys_context(?, ?) FROM DUAL")) {
            ps.setString(1, "USERENV");
            ps.setString(2, "SID");
            try (ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    sid = rs.getString(1);
                }
            }
        }
    }

    @After
    public void after() throws Exception {
        ctx.delete(T_MIMEDATA).execute();
    }

    @Test
    public void mcveTestFetchOne() {
        //  This test will work.
        int initCachedLobCount = this.getCachedLobCount();

        UUID uuid = UUID.randomUUID();
        String id = this.shortId(uuid);
        String pFilename = this.getID(uuid);
        String pDir = "MIMETEST";
        byte[] fileData = this.getData(10000);
        Routines.pBlobToFile(ctx.configuration(), fileData, pDir, pFilename);
        assertEquals(1,
                ctx.insertInto(T_MIMEDATA)
                .set(T_MIMEDATA.ID, id)
                .set(T_MIMEDATA.NAME, "testdata")
                .set(T_MIMEDATA.EXTSTORAGE, Routines.fBfilename(pDir, pFilename))
                .execute()
        );

        @Nullable TMimedataReadRecord record =
                ctx.fetchOne(T_MIMEDATA_READ, T_MIMEDATA_READ.ID.eq(id));
        assertNotNull(record.getId());
        int exitCachedLobCount = this.getCachedLobCount();
        assertEquals("Cached LOBs after run has changed.",
                initCachedLobCount, exitCachedLobCount);
    }

    @Test
    public void mcveTestSelectFromFetchOne() {
        //  This test will work.
        int initCachedLobCount = this.getCachedLobCount();

        UUID uuid = UUID.randomUUID();
        String id = this.shortId(uuid);
        String pFilename = this.getID(uuid);
        String pDir = "MIMETEST";
        byte[] fileData = this.getData(10000);
        Routines.pBlobToFile(ctx.configuration(), fileData, pDir, pFilename);
        assertEquals(1,
                ctx.insertInto(T_MIMEDATA)
                        .set(T_MIMEDATA.ID, id)
                        .set(T_MIMEDATA.NAME, "testdata")
                        .set(T_MIMEDATA.EXTSTORAGE, Routines.fBfilename(pDir, pFilename))
                        .execute()
        );

        @Nullable TMimedataReadRecord record =
                ctx.selectFrom(T_MIMEDATA_READ)
                        .where(T_MIMEDATA_READ.ID.eq(id))
                        .fetchOne();
        assertNotNull(record.getId());
        int exitCachedLobCount = this.getCachedLobCount();
        assertEquals("Cached LOBs after run has changed.",
                initCachedLobCount, exitCachedLobCount);
    }

    @Test
    public void mcveTestSelectFromFetch() {
        //  This test will fail.
        int initCachedLobCount = this.getCachedLobCount();

        UUID uuid = UUID.randomUUID();
        String id = this.shortId(uuid);
        String pFilename = this.getID(uuid);
        String pDir = "MIMETEST";
        byte[] fileData = this.getData(10000);
        Routines.pBlobToFile(ctx.configuration(), fileData, pDir, pFilename);
        assertEquals(1,
                ctx.insertInto(T_MIMEDATA)
                        .set(T_MIMEDATA.ID, id)
                        .set(T_MIMEDATA.NAME, "testdata")
                        .set(T_MIMEDATA.EXTSTORAGE, Routines.fBfilename(pDir, pFilename))
                        .execute()
        );

        @NotNull Result<TMimedataReadRecord> record =
                ctx.selectFrom(T_MIMEDATA_READ)
                        .where(T_MIMEDATA_READ.ID.eq(id))
                        .fetch();
        assertEquals(0, record.size());
        assertNotNull(record.get(0).getId());
        int exitCachedLobCount = this.getCachedLobCount();
        assertEquals("Cached LOBs after run has changed.",
                initCachedLobCount, exitCachedLobCount);
    }

    private String getID(UUID uuid) {
        return StringUtils.remove(uuid.toString(), '-');
    }

    private String shortId(UUID uuid) {
        byte[] buuid = ByteBuffer.allocate(16)
                .putLong(0, uuid.getMostSignificantBits())
                .putLong(8, uuid.getLeastSignificantBits())
                .array();
        return StringUtils.stripEnd(StringUtils.replaceChars(
                Base64.encodeBase64String(buuid), "/+", "_$"), "=");
    }

    private byte[] getData(int size) {
        Random ran = new Random();
        byte[] buffer = new byte[size];
        ran.nextBytes(buffer);
        return buffer;
    }

    private int getCachedLobCount() {
        int cachedLobCount = 0;
        try (PreparedStatement ps =
                     sysConnection.prepareStatement(
                             "SELECT \"CACHE_LOBS\" FROM \"V$TEMPORARY_LOBS\" WHERE \"SID\" = ?")) {
            ps.setString(1, sid);
            try (ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    cachedLobCount = rs.getInt(1);
                }
            }
        } catch (SQLException e) {
            throw new DataAccessException("Can not read cached LOB count.", e);
        }
        return cachedLobCount;
    }

}
